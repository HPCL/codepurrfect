```
./callgraph_gen.py -d <path-to-project-root-directory> 
                   -l <name-of-directory-to-hold-llvm-IR files>
                   -c <name-of-directory-to-hold-callgraph-csv-files> 
                   -i <name-of-directory-to-hold-files-with-pointer-names> 
                   -p <path-to-opt-plugin> 
                   -o <name-of-json-file-to-hold-pointer-to-runtime-names-map>
```

Assuming a compilation database (`compile_commands.json`) file exists in the root directory of a project (*petsc* for now), 
running the above command will create 3 directories and one json file. A directory to hold human 
readable llvm ir files (*.ll*), a directory to hold callgraphs (`<filepath>_callgraph.csv`), a directory with files 
that list all pointers called in the corresponding file (`<filepath>_indirects.txt`), and a json file with 
a mapping `pointer_name -> list of functions that might be called in pointers place at runtime`.

*Note* `<filepath>` is the file's full path with '/' replaced with '_'.

For example, assuming `~/xSDK/hpc-apps/petsc/petsc-3.15.0` is the path to *petsc* and our plugin 
is stored in `~/xSDK/hpc-apps/petsc/petsc-3.15.0`, running 

```
./callgraph_gen.py -d ~/xSDK/hpc-apps/petsc/petsc-3.15.0 
                   -l petsc-ll 
                   -c petsc-callgraph 
                   -i petsc-indirects 
                   -p build/PetscCallGraphXSDK/libPetscCallGraphXSDK.so 
                   -o indirect_calls.json 
```
will store callgraph files in `./petsc-callgraph`, *.ll* files in `./petsc-ll` 
and `<filepath>_indirects.txt` files in `./petsc-indirects`; while the mapping 
of pointer names to their corresponding concrete function names will be written 
to `indirect_calls.json`

--- 

Many code quality metrics rely on the code's control flow structures, among which its *callgraph*. Examples include metrics related to coupling, cohesion and code complexity in general.

The implementation in this directory addresses shortcomings in the callgraph-generating-capabilities provided by clang. 

One approach to building a *callgraph* statically, involves identifying all function definitions in a module, finding all function calls inside the definition and, creating a directed edge from the function being defined (the caller) to the each of the callees, and adding all these edges to the graph.

One problem with this approach is that sometimes actual callees cannot be known statically. In the case of overloaded operators, inherited operations, or indirect calls in general; information about the actual function to be called can only be known when the code is run. Currently, clang's callgraph generating capabilities choose not to deal with this issue: for every callgraph generated by clang, there exists only one node incident to which all indirect calls will be directed. Clearly this willl lead to inaccurate measurements of the metrics mentioned above. 

Even though C has no operator overloading, and does not support inheritance --- tricks to simulate both behaviors are common place. For example abstract classes can be simulated through the use of structs that declare prototypes of functions to be supported by a given class. As a consequence, this can lead to parametric polymorphism being simulated by passing arguments of the struct type to functions that can then treat any of the function pointers it specifies as if they were already defined. Therefore, if at runtime, any of the concrete classes--- structs whose pointers have been assigned implementations of those functions described by the "abstract class" --- is passed as argument to the polymorphic function, we are guaranteed execution of an actual function of the inheriting class/struct.    

However, even though we are unable to deduce which exact implementation of the child class will be executed statically; we argue that for the purposes of callgraph construction, we can do more than represent all indirect calls with a single node in the graph --- as clang currently does.  

The implementation we propose relies on *type-directed alias analysis* --- an analysis that attaches its results as *metadata* in LLVM's compilation pipeline --- to resolve the name of the anonymous function pointer in LLVM IR to its actual offset in the abstract struct. Because we have access to the whole implementation codebase, we can resolve the name of the polymorphic function and go even a step further and speculate about which actual implementation  provided by a child class will be called at runtime.   

---