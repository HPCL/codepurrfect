import os 
from   callgraphGen    import CGenRunner 
from   postprocessor   import post_process_callgraphs, post_func_files
import myglobals
from   multiprocessing import Pool 
from   typing          import List 



def create_tool_dirs(ast=False, pp=False, ir=False): 
    '''
    Create directories to hold data 
    generated by the tool. 

    Keyword arguments 

    func_only  -- Specify generation of list of functions only (as opposed to callgraphs)
    '''
    pwd   = os.getcwd() 
    pname = ''
    if pwd[-1] == '/':
        pname = pwd.split('/')[-2] 
    else: 
        pname = pwd.split('/')[-1]

    hide_prefix = '.'
    tool_dir    = hide_prefix + "quality-uo" 
    if not os.path.isdir(tool_dir): 
        os.mkdir(tool_dir) 

    ir_res_path, ast_res_path, pp_res_path = ("", "", "")

    if ir:
        ir_res_path             = tool_dir + "/" + pname + "-ir-metrics"
        if not os.path.isdir(ir_res_path): 
            os.mkdir(ir_res_path)
        # ll_res_path             = tool_dir + "/" + pname + "-ll"
        # call_res_path           = tool_dir + "/" + pname + "-callgraph"
        # callfile                = tool_dir + "/" + pname + "-callgraph.TabOne" 
        # cgmetrics_file          = tool_dir + "/" + pname + "-cgmetrics.csv"
        # nodes_file              = tool_dir + "/" + pname + "-funcnames.txt"

        # # TODO : GIVE USER CHOICE OF LEVEL WHERE TO CALCULATE THESE METRICS (i.e IR or AST)
        # qmetrics_path           = tool_dir + "/" + pname + "-qmetrics"  
        # qmfile                  = tool_dir + "/" + pname + "-qmetrics.csv" 

        # if not os.path.isdir(call_res_path): 
        #     os.mkdir(call_res_path)

        # if not os.path.isdir(qmetrics_path): 
        #     os.mkdir(qmetrics_path)

    if ast:
        ast_res_path            = tool_dir + "/" + pname + "-ast-metrics"
        if not os.path.isdir(ast_res_path): 
                os.mkdir(ast_res_path)

    if pp:
        pp_res_path             = tool_dir + '/' + pname + "-pp-metrics"
        if not os.path.isdir(pp_res_path): 
                os.mkdir(pp_res_path)
    # else: 
    #     func_only_res_path = tool_dir + "/" + pname + "-functions.txt"
    
    # if not os.path.isdir(ll_res_path): 
    #     os.mkdir(ll_res_path) 


    # if not func_only: 
    #     return (pname, callfile, cgmetrics_file, qmfile, nodes_file, 
    #                    ll_res_path, call_res_path, 
    #                    ast_res_path, pp_res_path, qmetrics_path)
    # else: 
    return (pname, ir_res_path, ast_res_path, pp_res_path) 


class PassRunner: 
    def __init__(self, initL : List[str], ir_passes  : List[str] = []
                                        , ast_passes : List[str] = []
                                        , pp_passes  : List[str] = []) -> None:
        '''
        Create tool directories, and create the 
        generator. Call *run* to actually run the generator. 

        Keyword arguments: 

        initL      -- Value of union type representing arguments to the --init flag
        cgPass     -- Whether to run the callgraph generation pass (default = True) 
        ast_passes -- List of ast-level passes to run (default = False)
        '''
        self.generator     = None 

        self.has_ir_pass   = ir_passes  != []  
        self.has_ast_pass  = ast_passes != [] 
        self.has_pp_pass   = pp_passes  != [] 

        self.ir_passes     = ir_passes 
        self.ast_passes    = ast_passes
        self.pp_passes     = pp_passes 

        self.proj_name       = None 

        self.ast_output_dirs = None 
        self.pp_output_dirs  = None 
        self.ir_output_dirs  = None 
        
        if self.has_ir_pass: 
            self.call_res_path = None
            self.callfile      = None 
            self.outfile       = None 
            self.nodes_file    = None

            self.qmetrics_path = None 
            self.qmfile        = None 
             

        if self.has_ast_pass: 
            self.ast_res_path = None 

        if self.has_pp_pass: 
            self.pp_res_path = None 

        self.proj_name,  self.ir_res_path, \
                         self.ast_res_path, \
                         self.pp_res_path = create_tool_dirs(ir=self.has_ir_pass, 
                                                             ast=self.has_ast_pass, 
                                                             pp=self.has_pp_pass)
        cgGenerator = CGenRunner(
                        dirpath=self.proj_name,
                        astpath=self.ast_res_path,
                        pppath=self.pp_res_path,
                        irpath=self.ir_res_path
                    )


            # self.proj_name     = proj_root_dir 
            # self.call_res_path = call_res_path 
            # self.ast_res_path  = ast_res_path
            # self.pp_res_path   = pp_res_path
            # self.qmetrics_path = qmetrics_path 
            # self.callfile      = callfile 
            # self.outfile       = cgmetrics_file 
            # self.qmfile        = qmfile 
            # self.nodes_file    = nodes_file


        self.generator = cgGenerator


        # functions only pass 
        # if TODO: DELETE: 
        #     proj_root_dir, ll_res_path, func_only_res_path = create_tool_dirs(func_only=True)
        #     fltrd_filepath = initL[0] 
        #     funcGenerator = CGenRunner(dirpath=proj_root_dir, llpath=ll_res_path
        #                                                     , fltrd_filepath=fltrd_filepath
        #                                                     , fltrd_outpath=func_only_res_path
        #                                                     , funcpluginpath=myglobals.config_vars["func_only_plugin_path"])
        #     self.func_only_res_path = func_only_res_path
        #     self.generator = funcGenerator

        # other passes




    def run(self, pool : Pool, ast_passes : List[str] = [], pp_passes : List[str] = [], ir_passes : List[str] = []) -> None: 
        '''
        Generate data in parallel and store in 
        generated tool directories. 

        Keyword arguments: 

        pool       -- *multiprocessing* Pool of threads to use 
        ast_passes -- list of ast passes to run (default = [])
        '''
        if self.has_ir_pass: 
            ir_pass_output_dirs = self.generator.gen_ir_metrics(pool, ir_passes=ir_passes)
            self.ir_output_dirs = ir_pass_output_dirs

        if self.has_ast_pass:
            ast_pass_output_dirs = self.generator.gen_ast_metrics(project_name=self.proj_name, passes=ast_passes)
            self.ast_output_dirs = ast_pass_output_dirs

        if self.has_pp_pass:
            pp_pass_output_dirs = self.generator.gen_pp_metrics(project_name=self.proj_name, passes=pp_passes) 
            self.pp_output_dirs = pp_pass_output_dirs

            # self.generator.calculate_locs(pool) 

    def move_output_files(self, _passes : List[str], pass_type : str): 
        cwd         = os.getcwd() 
        check       = False 
        output_dirs = ""
        if pass_type == "ir": 
            check       = self.has_ir_pass
            output_dirs = self.ir_output_dirs 

        if pass_type == "ast": 
            check       = self.has_ast_pass 
            output_dirs = self.ast_output_dirs 

        if pass_type == "pp" : 
            check       = self.has_pp_pass 
            output_dirs = self.pp_output_dirs 

        if check:
            for _pass in _passes: 
                self.generator.move_files(frm=cwd, 
                                        destinations=output_dirs, 
                                        extensions=myglobals.config_vars[pass_type][_pass]["extensions"])


    def combine_output_files(self, passes : List[str], pass_type : str): 
        check    = False
        out_dirs = "" 
        if pass_type == "ast": 
            check    = self.has_ast_pass
            out_dirs = self.ast_output_dirs 
        if pass_type == "pp": 
            check    = self.has_pp_pass 
            out_dirs = self.pp_output_dirs 
        if pass_type == "ir": 
            check    = self.has_ir_pass
            out_dirs = self.ir_output_dirs

        if check: 
            for _pass in passes: 
                for extension in myglobals.config_vars[pass_type][_pass]["extensions"]:
                    _out_dir = [d for d in out_dirs if _pass in d][0] 
                    f_counts = 0 
                    g_file   = '/'.join([_out_dir, self.proj_name + "-" + extension])
                    with open(g_file, 'w') as g_file_w:
                        for pass_file in os.listdir(_out_dir): 
                            pass_file_path = '/'.join([_out_dir, pass_file])
                            if os.path.isfile(pass_file_path): 
                                if extension in pass_file: 
                                    with open(pass_file_path, 'r') as pass_file_r: 
                                        f_contents = []
                                        if f_counts > 0: 
                                            f_contents = pass_file_r.readlines()[1:]
                                        else: 
                                            f_contents = pass_file_r.readlines() 
                                        g_file_w.writelines(f_contents)
                                    f_counts += 1



    def post_process_pass(self): 
        '''
        Move generated files to their respective 
        directories and delete unncessary files
        '''
        if self.has_ir_pass: 
            post_process_callgraphs(
                proj_name=self.proj_name, 
                call_res_path=self.call_res_path,
                ast_res_path=self.ast_res_path,
                pp_res_path=self.pp_res_path,
                qmetrics_path=self.qmetrics_path,
                callfile=self.callfile, 
                outfile=self.outfile, 
                qmfile=self.qmfile, 
                nodes_file=self.nodes_file, 
                ast_pass_names=self.ast_passes,
                ast_output_dirs=self.ast_output_dirs, 
                pp_pass_names=self.pp_passes, 
                pp_output_dirs=self.pp_output_dirs
            )













    
